#!/usr/bin/env python3

from __future__ import print_function

import argparse
import os
import sys
import time

try:
    from ament_lint_cmake import get_xunit_content
except ImportError:
    # support running the script from source
    if not os.path.exists(
            os.path.join(os.path.dirname(os.path.dirname(__file__)),
                         'ament_lint_cmake-extras.cmake')):
        raise
    sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
    from ament_lint_cmake import get_xunit_content
import ament_lint_cmake.cmakelint as cmakelint


def main(argv=sys.argv[1:]):
    parser = argparse.ArgumentParser(
        description='Check CMake code against the style conventions.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        'paths',
        nargs='*',
        default=[os.curdir],
        help="The files or directories to check. For directories files named "
             "'CMakeLists.txt' and ending in '.cmake' will be considered.")
    # not using a file handle directly
    # in order to prevent leaving an empty file when something fails early
    parser.add_argument(
        '--xunit-file',
        help='Generate a xunit compliant XML file')
    args = parser.parse_args(argv)

    if args.xunit_file:
        start_time = time.time()

    files = get_files(args.paths)
    if not files:
        print('No files found', file=sys.stderr)
        return 1

    # hook into error reporting
    DefaultError = cmakelint.Error
    report = []

    # invoke cmake lint
    cmakelint._lint_state.config = cmakelint._DEFAULT_CMAKELINTRC
    for filename in files:
        # hook into error reporting
        errors = []

        def custom_error(filename, linenumber, category, message):
            if cmakelint.ShouldPrintError(category):
                errors.append({
                    'linenumber': linenumber,
                    'category': category,
                    'message': message,
                })
            DefaultError(filename, linenumber, category, message)
        cmakelint.Error = custom_error

        cmakelint.ProcessFile(filename)
        report.append((filename, errors))
        if errors:
            print('')

    # print summary
    print('')
    if not cmakelint._lint_state.errors:
        print('No errors')
        rc = 0
    else:
        print('%d errors' % cmakelint._lint_state.errors)
        rc = 1

    # generate xunit file
    if args.xunit_file:
        testname = os.path.basename(args.xunit_file)
        suffix = '.xml'
        if testname.endswith(suffix):
            testname = testname[0:-len(suffix)]
        xml = get_xunit_content(report, testname, time.time() - start_time)
        path = os.path.dirname(os.path.abspath(args.xunit_file))
        if not os.path.exists(path):
            os.makedirs(path)
        with open(args.xunit_file, 'w') as f:
            f.write(xml)

    return rc


def get_files(paths):
    files = []
    for path in paths:
        if os.path.isdir(path):
            for dirpath, dirnames, filenames in os.walk(path):
                # ignore folder starting with . or _
                dirnames[:] = [d for d in dirnames if d[0] not in ['.', '_']]
                dirnames.sort()

                # select files by name  / extension
                for filename in sorted(filenames):
                    if filename.lower() == 'CMakeLists.txt'.lower() or \
                            filename.endswith('.cmake'):
                        files.append(os.path.join(dirpath, filename))
        if os.path.isfile(path):
            files.append(path)
    return files


if __name__ == '__main__':
    sys.exit(main())
