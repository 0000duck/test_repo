Index: src/LinearMath/btQuaternion.h
===================================================================
--- src/LinearMath/btQuaternion.h	(revision 1779)
+++ src/LinearMath/btQuaternion.h	(working copy)
@@ -44,7 +44,7 @@
    * @param yaw Angle around Y unless BT_EULER_DEFAULT_ZYX defined then Z
    * @param pitch Angle around X unless BT_EULER_DEFAULT_ZYX defined then Y
    * @param roll Angle around Z unless BT_EULER_DEFAULT_ZYX defined then X */
-	btQuaternion(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
+  btQuaternion(const btScalar& yaw, const btScalar& pitch, const btScalar& roll) __attribute__((deprecated))
 	{ 
 #ifndef BT_EULER_DEFAULT_ZYX
 		setEuler(yaw, pitch, roll); 
@@ -87,7 +87,7 @@
    * @param yaw Angle around Z
    * @param pitch Angle around Y
    * @param roll Angle around X */
-	void setEulerZYX(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
+  void setEulerZYX(const btScalar& yaw, const btScalar& pitch, const btScalar& roll) __attribute__((deprecated))
 	{
 		btScalar halfYaw = btScalar(yaw) * btScalar(0.5);  
 		btScalar halfPitch = btScalar(pitch) * btScalar(0.5);  
Index: src/LinearMath/btMatrix3x3.h
===================================================================
--- src/LinearMath/btMatrix3x3.h	(revision 1779)
+++ src/LinearMath/btMatrix3x3.h	(working copy)
@@ -148,27 +148,26 @@
 		}
 		
 
-  /** @brief Set the matrix from euler angles using YPR around YXZ respectively
-   *  @param yaw Yaw about Y axis
-   *  @param pitch Pitch about X axis
-   *  @param roll Roll about Z axis 
+  /** @brief Set the matrix from euler angles using YPR around ZYX respectively
+   *  @param yaw Yaw about Z axis
+   *  @param pitch Pitch about Y axis
+   *  @param roll Roll about X axis 
    */
-		void setEulerYPR(const btScalar& yaw, const btScalar& pitch, const btScalar& roll) 
+		void setEulerZYX(const btScalar& yaw, const btScalar& pitch, const btScalar& roll) __attribute__((deprecated))
 		{
-			setEulerZYX(roll, pitch, yaw);
+			setEulerYPR(yaw, pitch, roll);
 		}
 
 	/** @brief Set the matrix from euler angles YPR around ZYX axes
+         * @param eulerZ Yaw aboud Z axis
+         * @param eulerY Pitch around Y axis
 	 * @param eulerX Roll about X axis
-         * @param eulerY Pitch around Y axis
-         * @param eulerZ Yaw aboud Z axis
          * 
 	 * These angles are used to produce a rotation matrix. The euler
 	 * angles are applied in ZYX order. I.e a vector is first rotated 
 	 * about X then Y and then Z
 	 **/
-	void setEulerZYX(btScalar eulerX,btScalar eulerY,btScalar eulerZ) { 
-  ///@todo proposed to reverse this since it's labeled zyx but takes arguments xyz and it will match all other parts of the code
+	void setEulerZYX(btScalar eulerZ, btScalar eulerY,btScalar eulerX)  { 
 		btScalar ci ( btCos(eulerX)); 
 		btScalar cj ( btCos(eulerY)); 
 		btScalar ch ( btCos(eulerZ)); 
@@ -284,11 +306,11 @@
 
 
   /**@brief Get the matrix represented as euler angles around ZYX
-   * @param yaw Yaw around X axis
+   * @param yaw Yaw around Z axis
    * @param pitch Pitch around Y axis
    * @param roll around X axis 
    * @param solution_number Which solution of two possible solutions ( 1 or 2) are possible values*/	
-  void getEulerZYX(btScalar& yaw, btScalar& pitch, btScalar& roll, unsigned int solution_number = 1) const
+  __attribute__((deprecated)) void getEulerZYX(btScalar& yaw, btScalar& pitch, btScalar& roll, unsigned int solution_number = 1) const
   {
     struct Euler{btScalar yaw, pitch, roll;};
     Euler euler_out;
