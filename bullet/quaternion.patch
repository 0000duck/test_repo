Index: src/LinearMath/btQuaternion.h
===================================================================
--- src/LinearMath/btQuaternion.h	(revision 2038)
+++ src/LinearMath/btQuaternion.h	(working copy)
@@ -200,8 +208,19 @@
 	{
 		btScalar s = btSqrt(length2() * q.length2());
 		btAssert(s != btScalar(0.0));
-		return btAcos(dot(q) / s);
+		return btAcos(dot(q) / s) * btScalar(2.0);
 	}
+	/**@brief Return the angle between this quaternion and the other along the shortest path
+	* @param q The other quaternion */
+	btScalar angleShortestPath(const btQuaternion& q) const 
+	{
+		btScalar s = btSqrt(length2() * q.length2());
+		btAssert(s != btScalar(0.0));
+		if (dot(q) < 0) // Take care of long angle case see http://en.wikipedia.org/wiki/Slerp
+			return btAcos(dot(-q) / s) * btScalar(2.0);
+		else 
+			return btAcos(dot(q) / s) * btScalar(2.0);
+	}
   /**@brief Return the angle of rotation represented by this quaternion */
 	btScalar getAngle() const 
 	{
@@ -209,6 +228,18 @@
 		return s;
 	}
 
+	/**@brief Return the angle of rotation represented by this quaternion along the shortest path*/
+	btScalar getAngleShortestPath() const 
+	{
+	btScalar s;
+		if (dot(*this) < 0)
+			s = btScalar(2.) * btAcos(m_floats[3]);
+		else
+			s = btScalar(2.) * btAcos(-m_floats[3]);
+
+		return s;
+	}
+
 	/**@brief Return the axis of the rotation represented by this quaternion */
 	btVector3 getAxis() const
 	{
@@ -373,6 +404,13 @@
 	return q1.angle(q2); 
 }
 
+/**@brief Return the shortest angle between two quaternions*/
+SIMD_FORCE_INLINE btScalar
+angleShortestPath(const btQuaternion& q1, const btQuaternion& q2) 
+{ 
+	return q1.angleShortestPath(q2); 
+}
+
 /**@brief Return the inverse of a quaternion*/
 SIMD_FORCE_INLINE btQuaternion
 inverse(const btQuaternion& q) 
