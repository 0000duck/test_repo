Index: src/LinearMath/euler_test_unpatched.cpp
===================================================================
--- src/LinearMath/euler_test_unpatched.cpp	(revision 0)
+++ src/LinearMath/euler_test_unpatched.cpp	(revision 0)
@@ -0,0 +1,279 @@
+#include <cstdio>
+#include "btMatrix3x3.h"
+#include "btQuaternion.h"
+#include "btTransform.h"
+
+int main(int argc, char** argv)
+{
+  double ninty = M_PI/2.0;
+  double fourty5 = M_PI/4.0;
+  double twelve = M_PI/15.0;
+  btVector3 vec_id(0,0,0);
+
+  printf("This is an euler angle test program\n");
+
+  btQuaternion q;
+  btMatrix3x3 mat;
+  btTransform tr;
+  btVector3 vin(1,0,0);
+  btVector3 vout;
+
+  printf ("\n\nQuaternion setEulerZYX yaw pitch roll angles\n\n");
+
+  q.setEulerZYX(ninty, 0, 0);
+  vout = btTransform(q, vec_id) * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  if (vout.y() == vin.x() ) 
+    printf("quaternion setEulerZYX yaw IS about Z\n");
+  else
+    printf("quaternion setEulerZYX yaw IS NOT about Z\n");
+
+  q.setEulerZYX(0,ninty, 0);
+  vout = btTransform(q, vec_id) * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  if (vout.z() == -vin.x() ) 
+    printf("quaternion setEulerZYX pitch IS about Y\n");
+  else
+    printf("quaternion setEulerZYX pitch IS NOT about Y\n");
+
+  q.setEulerZYX(0, 0, ninty);
+  vout = btTransform(q, vec_id) * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  if (vout.x() == vin.x() ) 
+    printf("quaternion setEulerZYX roll IS about X\n");
+  else
+    printf("quaternion setEulerZYX roll IS NOT about X\n");
+
+  printf ("\n\nbtMatrix setEulerZYX yaw pitch roll angles\n\n");
+
+  mat.setEulerZYX(0, 0, ninty);
+  vout = btTransform(mat, vec_id) * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  if (vout.y() == vin.x() ) 
+    printf("matrix setEulerZYX yaw IS about Z\n");
+  else
+    printf("matrix setEulerZYX yaw IS NOT about Z\n");
+
+  mat.setEulerZYX(0,ninty, 0);
+  vout = btTransform(mat, vec_id) * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  if (vout.z() == -vin.x() ) 
+    printf("matrix setEulerZYX pitch IS about Y\n");
+  else
+    printf("matrix setEulerZYX pitch IS NOT about Y\n");
+
+  mat.setEulerZYX(ninty, 0, 0);
+  vout = btTransform(mat, vec_id) * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  if (vout.x() == vin.x() ) 
+    printf("matrix setEulerZYX roll IS about X\n");
+  else
+    printf("matrix setEulerZYX roll IS NOT about X\n");
+
+
+  printf ("\n\nMatrix setEulerYPR yaw pitch roll angles\n\n");
+  mat.setEulerYPR(ninty, 0, 0);
+  vout = btTransform(mat, vec_id) * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  if (vout.y() == vin.x() ) 
+    printf("matrix setEulerYPR yaw IS about Z\n");
+  else
+    printf("matrix setEulerYPR yaw IS NOT about Z\n");
+
+  mat.setEulerYPR(0,ninty, 0);
+  vout = btTransform(mat, vec_id) * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  if (vout.z() == -vin.x() ) 
+    printf("matrix setEulerYPR pitch IS about Y\n");
+  else
+    printf("matrix setEulerYPR pitch IS NOT about Y\n");
+
+  mat.setEulerYPR(0, 0, ninty);
+  vout = btTransform(mat, vec_id) * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  if (vout.x() == vin.x() ) 
+    printf("matrix setEulerYPR roll IS about X\n");
+  else
+    printf("matrix setEulerYPR roll IS NOT about X\n");
+
+  printf ("\n\nMatrix getEulerYPR yaw pitch roll angles\n\n");
+  mat.setEulerYPR(twelve, 0, 0);
+  btScalar y, p, r;
+  mat.getEulerYPR(y, p, r);
+  if (y == twelve)
+    printf ("getEulerYPR yaw is the same as setEulerYPR yaw\n");
+  else
+    printf ("getEulerYPR yaw is the same as setEulerYPR yaw\n");
+
+  mat.setEulerYPR(0, twelve, 0);
+  mat.getEulerYPR(y, p, r);
+  if (p == twelve)
+    printf ("getEulerYPR pitch is the same as setEulerYPR pitch\n");
+  else
+    printf ("getEulerYPR pitch is the same as setEulerYPR pitch\n");
+
+  mat.setEulerYPR(0, 0, twelve);
+  mat.getEulerYPR(y, p, r);
+  if (r == twelve)
+    printf ("getEulerYPR roll is the same as setEulerYPR roll\n");
+  else
+    printf ("getEulerYPR roll is the same as setEulerYPR roll\n");
+
+  printf ("\n\nMatrix YPR Order\n\n");
+  btVector3 vout2;
+  btMatrix3x3 mat1, mat2, mat3;
+  //DUAL ROTATION
+  mat.setEulerYPR(ninty, fourty5, twelve);
+
+  mat1.setEulerYPR(ninty, 0, 0);
+  mat2.setEulerYPR(0, fourty5, 0);
+  mat3.setEulerYPR(0, 0, twelve);
+
+  vin = btVector3(1,0,0);
+  vout = btTransform(mat, vec_id) * vin;
+  vout2 = btTransform(mat1, vec_id) * btTransform(mat2, vec_id) * btTransform(mat3, vec_id)  * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  printf("Vout2 %f %f %f\n", vout2.x(), vout2.y(), vout2.z());
+  if (fabs(vout.x() - vout2.x()) < 0.001 && fabs(vout.y() - vout2.y()) < 0.001 && fabs(vout.z() - vout2.z()) < 0.001 ) 
+    printf("matrix setEulerYPR is in ZYX order\n");
+  else
+    printf("matrix setEulerYPR roll IS NOT in ZYX order\n");
+  
+  vin = btVector3(0,1,0);
+  vout = btTransform(mat, vec_id) * vin;
+  vout2 = btTransform(mat1, vec_id) * btTransform(mat2, vec_id) * btTransform(mat3, vec_id)  * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  printf("Vout2 %f %f %f\n", vout2.x(), vout2.y(), vout2.z());
+  if (fabs(vout.x() - vout2.x()) < 0.001 && fabs(vout.y() - vout2.y()) < 0.001 && fabs(vout.z() - vout2.z()) < 0.001 ) 
+    printf("matrix setEulerYPR is in ZYX order\n");
+  else
+    printf("matrix setEulerYPR roll IS NOT in ZYX order\n");
+  
+  vin = btVector3(0,0,1);
+  vout = btTransform(mat, vec_id) * vin;
+  vout2 = btTransform(mat1, vec_id) * btTransform(mat2, vec_id) * btTransform(mat3, vec_id)  * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  printf("Vout2 %f %f %f\n", vout2.x(), vout2.y(), vout2.z());
+  if (fabs(vout.x() - vout2.x()) < 0.001 && fabs(vout.y() - vout2.y()) < 0.001 && fabs(vout.z() - vout2.z()) < 0.001 ) 
+    printf("matrix setEulerYPR is in ZYX order\n");
+  else
+    printf("matrix setEulerYPR roll IS NOT in ZYX order\n");
+
+
+  printf ("\n\nMatrix ZYX Order\n\n");
+  mat.setEulerZYX(ninty,fourty5, twelve);
+
+  mat1.setEulerZYX(ninty, 0, 0);
+  mat2.setEulerZYX(0, fourty5, 0);
+  mat3.setEulerZYX(0, 0, twelve);
+
+  vin = btVector3(1,0,0);
+  vout = btTransform(mat, vec_id) * vin;
+  vout2 = btTransform(mat3, vec_id) * btTransform(mat2, vec_id) * btTransform(mat1, vec_id)  * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  printf("Vout2 %f %f %f\n", vout2.x(), vout2.y(), vout2.z());
+  if (fabs(vout.x() - vout2.x()) < 0.001 && fabs(vout.y() - vout2.y()) < 0.001 && fabs(vout.z() - vout2.z()) < 0.001 ) 
+    printf("matrix setEulerZYX is in ZYX order\n");
+  else
+    printf("matrix setEulerZYX roll IS NOT in ZYX order\n");
+  
+  vin = btVector3(0,1,0);
+  vout = btTransform(mat, vec_id) * vin;
+  vout2 = btTransform(mat3, vec_id) * btTransform(mat2, vec_id) * btTransform(mat1, vec_id)  * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  printf("Vout2 %f %f %f\n", vout2.x(), vout2.y(), vout2.z());
+  if (fabs(vout.x() - vout2.x()) < 0.001 && fabs(vout.y() - vout2.y()) < 0.001 && fabs(vout.z() - vout2.z()) < 0.001 ) 
+    printf("matrix setEulerZYX is in ZYX order\n");
+  else
+    printf("matrix setEulerZYX roll IS NOT in ZYX order\n");
+  
+  vin = btVector3(0,0,1);
+  vout = btTransform(mat, vec_id) * vin;
+  vout2 = btTransform(mat3, vec_id) * btTransform(mat2, vec_id) * btTransform(mat1, vec_id)  * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  printf("Vout2 %f %f %f\n", vout2.x(), vout2.y(), vout2.z());
+  if (fabs(vout.x() - vout2.x()) < 0.001 && fabs(vout.y() - vout2.y()) < 0.001 && fabs(vout.z() - vout2.z()) < 0.001 ) 
+    printf("matrix setEulerZYX is in ZYX order\n");
+  else
+    printf("matrix setEulerZYX roll IS NOT in ZYX order\n");
+
+
+  printf ("\n\nQuaternion ZYX Order\n\n");
+  btQuaternion q1, q2, q3;
+  q.setEulerZYX(ninty, fourty5, twelve);
+
+  q1.setEulerZYX(ninty, 0, 0);
+  q2.setEulerZYX(0, fourty5, 0);
+  q3.setEulerZYX(0, 0, twelve);
+
+  vin = btVector3(1,0,0);
+  vout = btTransform(q, vec_id) * vin;
+  vout2 = btTransform(q1, vec_id) * btTransform(q2, vec_id) * btTransform(q3, vec_id)  * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  printf("Vout2 %f %f %f\n", vout2.x(), vout2.y(), vout2.z());
+  if (fabs(vout.x() - vout2.x()) < 0.001 && fabs(vout.y() - vout2.y()) < 0.001 && fabs(vout.z() - vout2.z()) < 0.001 ) 
+    printf("quaternion setEulerZYX is in ZYX order\n");
+  else
+    printf("quaternion setEulerZYX roll IS NOT in ZYX order\n");
+  
+  vin = btVector3(0,1,0);
+  vout = btTransform(q, vec_id) * vin;
+  vout2 = btTransform(q1, vec_id) * btTransform(q2, vec_id) * btTransform(q3, vec_id)  * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  printf("Vout2 %f %f %f\n", vout2.x(), vout2.y(), vout2.z());
+  if (fabs(vout.x() - vout2.x()) < 0.001 && fabs(vout.y() - vout2.y()) < 0.001 && fabs(vout.z() - vout2.z()) < 0.001 ) 
+    printf("quaternion setEulerZYX is in ZYX order\n");
+  else
+    printf("quaternion setEulerZYX roll IS NOT in ZYX order\n");
+  
+  vin = btVector3(0,0,1);
+  vout = btTransform(q, vec_id) * vin;
+  vout2 = btTransform(q1, vec_id) * btTransform(q2, vec_id) * btTransform(q3, vec_id)  * vin;
+
+  printf("Vout %f %f %f\n", vout.x(), vout.y(), vout.z());
+  printf("Vout2 %f %f %f\n", vout2.x(), vout2.y(), vout2.z());
+  if (fabs(vout.x() - vout2.x()) < 0.001 && fabs(vout.y() - vout2.y()) < 0.001 && fabs(vout.z() - vout2.z()) < 0.001 ) 
+    printf("quaternion setEulerZYX is in ZYX order\n");
+  else
+    printf("quaternion setEulerZYX roll IS NOT in ZYX order\n");
+
+
+
+  printf("\n\nMatrix GetEulerZYX\n\n");
+  mat.setEulerZYX(twelve, fourty5, twelve+ .1);
+  btScalar yaw, pitch, roll;
+  mat.getEulerZYX( yaw, pitch, roll);
+  printf("%f %f %f vs %f %f %f\n", twelve, fourty5, twelve + .1, roll, pitch, yaw);
+  if (fabs(roll - twelve) < 0.0001 && fabs(pitch - fourty5) < .0001 && fabs(yaw - twelve - .1) < 0.0001)
+    printf("getEulerZYX SAME order, but different argument order\n");
+  else
+    printf("getEulerZYX DIFFERENT order\n");
+
+  printf("\n\nMatrix GetEulerYPR\n\n");
+  mat.setEulerYPR(twelve, fourty5, twelve+ .1);
+  mat.getEulerYPR( roll, pitch, yaw);
+  printf("%f %f %f vs %f %f %f\n", twelve, fourty5, twelve + .1, roll, pitch, yaw);
+  if (fabs(roll - twelve) < 0.0001 && fabs(pitch - fourty5) < .0001 && fabs(yaw - twelve - .1) < 0.0001)
+    printf("getEulerYPR SAME order\n");
+  else
+    printf("getEulerYPR DIFFERENT order\n");
+
+  return 0;
+};
Index: src/LinearMath/CMakeLists.txt
===================================================================
--- src/LinearMath/CMakeLists.txt	(revision 1779)
+++ src/LinearMath/CMakeLists.txt	(working copy)
@@ -53,3 +53,6 @@
 	SET_TARGET_PROPERTIES(LinearMath PROPERTIES FRAMEWORK true)
 	SET_TARGET_PROPERTIES(LinearMath PROPERTIES PUBLIC_HEADER "${LinearMath_HDRS}")
 ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+
+ADD_EXECUTABLE(euler_test_unpatched euler_test_unpatched.cpp)
+TARGET_LINK_LIBRARIES(euler_test_unpatched LinearMath)
\ No newline at end of file
