USER DEADLINE EAMPLE
--------------------

-------------------
-Working principle-
-------------------

The Deadline QoS is checked with a constant time period. If set to 100ms,
every 100ms a report indicating which keys inside the topic have not sent new
data is generated.

This report is generated by the QoS operation, run every time period, and
consting on checking if a message arrival flag has been set for each key since
the last execution. As flags are reset at the end of the operation, a flag set
to 1 indicated data arrival in that period.

----------------
-Implementation-
----------------

In this example, the Deadline QoS is implemented with a helper class
DeadlineQoS. This class implements:
- A map of flag bits for each key (with mutex to ensure exclusive access)
- A method for onNewDataMessage to set flags on the QoS map
- A callback function to check the QoS periodically
- A function to activate the process

This auxiliary class has to be instanciated as a member os m_listener on the
subscriber. To use it:
- Initialize the class on m_listener constructor
- Update the flags on each message arrival by calling setFlag(key) from
  onNewDataMessage
- Launch the QoS check once from the run() method

Remember that to distinguish between keys, the topic must be configured to do
so.

-------
-USAGE-
-------

The Deadline QoS affects the subscriber only. An instance of deadlineQoS is
created inside of m_listener.
The service is activated by calling deadlineQoS::run(), which spawns a
dedicated thread to run the checks.
On new data arrival there is additional logic to set the key's associated flag
to 1
The subscriber's response to a missed Deadline QoS event on a key is defined
on deadlineQoS::callback().

