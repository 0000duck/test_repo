/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * fastcdr_LICENSE file included in this fastcdr distribution.
 *
 *************************************************************************
 * 
 * @file deadlinepayloadPublisher.cpp
 * This file contains the implementation of the publisher functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include <fastrtps/participant/Participant.h>
#include <fastrtps/attributes/ParticipantAttributes.h>
#include <fastrtps/publisher/Publisher.h>
#include <fastrtps/attributes/PublisherAttributes.h>

#include <fastrtps/Domain.h>

#include <fastrtps/utils/eClock.h>

#include "deadlinepayloadPublisher.h"




deadlinepayloadPublisher::deadlinepayloadPublisher() : mp_participant(nullptr), mp_publisher(nullptr), double_time(false) {}

deadlinepayloadPublisher::~deadlinepayloadPublisher() {	Domain::removeParticipant(mp_participant);}

bool deadlinepayloadPublisher::init()
{
	// Create RTPSParticipant
	
	ParticipantAttributes PParam;
	PParam.rtps.builtin.domainId = 0;
	PParam.rtps.builtin.leaseDuration = c_TimeInfinite;
	PParam.rtps.setName("Participant_publisher");  //You can put here the name you want
	mp_participant = Domain::createParticipant(PParam);	
	if(mp_participant == nullptr)
		return false;
	
	//Register the type
	
	Domain::registerType(mp_participant,(TopicDataType*) &myType);
	
	// Create Publisher
	
	PublisherAttributes Wparam;
	Wparam.topic.topicKind = WITH_KEY;
	Wparam.topic.topicDataType = myType.getName();  //This type MUST be registered
	Wparam.topic.topicName = "deadlinepayloadPubSubTopic";
	Wparam.topic.resourceLimitsQos.max_instances=32;
	Wparam.topic.resourceLimitsQos.max_samples_per_instance=5;
	Wparam.topic.resourceLimitsQos.max_samples = 32*5;
	Wparam.topic.historyQos.depth = 5;
	mp_publisher = Domain::createPublisher(mp_participant,Wparam,(PublisherListener*)&m_listener);
	if(mp_publisher == nullptr)
		return false;
	cout << "Publisher created, waiting for Subscribers." << endl;
	return true;
}

void deadlinepayloadPublisher::PubListener::onPublicationMatched(Publisher* /*pub*/,MatchingInfo& info)
{
	if (info.status == MATCHED_MATCHING)
	{
		n_matched++;
		cout << "Publisher matched" << endl;
	}
	else
	{
		n_matched--;
		cout << "Publisher unmatched" << endl;
	}
}

void deadlinepayloadPublisher::run()
{
	while(m_listener.n_matched == 0)
	{
		eClock::my_sleep(250); // Sleep 250 ms
	}
	
	// Publication code
	
	HelloMsg st;
	std::stringstream stream;
	//Filling sample message
	stream << "generic payload";
	st.payload(stream.str());

	/* Initialize your structure here */
	
	while(true){
		eClock::my_sleep(900);

		//Send messages
		for(unsigned short i=0;i<32;i++){
			st.deadlinekey(i);				//Set key
			if(i==15){						//Force key 15 message to be sent half of the times
				double_time = !double_time;
				if(double_time)	mp_publisher->write(&st);
			}else{
				mp_publisher->write(&st);
			}
		}
	}
}
