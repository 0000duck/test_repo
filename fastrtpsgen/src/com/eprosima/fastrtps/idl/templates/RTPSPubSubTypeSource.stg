group ProtocolHeader;

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "PubSubTypes.cpp"], description=["This header file contains the implementation of the serialization functions."])$


#include "fastcdr/FastBuffer.h"
#include "fastcdr/Cdr.h"

#include "$ctx.filename$PubSubTypes.h"

$definitions; separator="\n"$

>>

module(ctx, module, definition_list) ::= <<
namespace $module.name$
{
    $definition_list$
} //End of namespace $module.name$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$

>>

interface(ctx, interface, export_list) ::= <<
$export_list$
>>

export_list(exports) ::= <<
$exports; separator="\n"$

>>

exception(ctx, exception) ::= <<>>

operation(ctx, operation, param_list) ::= <<>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

const_decl(ctx, const) ::= <<>>

typedef_decl(ctx, typedefs) ::= <<>>

struct_type(ctx, struct) ::= <<
$struct.name$PubSubType::$struct.name$PubSubType() {
	setName("$struct.scopedname$");
	m_typeSize = (uint32_t)$struct.name$::getMaxCdrSerializedSize();
	m_isGetKeyDefined = $struct.name$::isKeyDefined();
	m_keyBuffer = (unsigned char*)malloc($struct.name$::getKeyMaxCdrSerializedSize()>16 ? $struct.name$::getKeyMaxCdrSerializedSize() : 16);
}

$struct.name$PubSubType::~$struct.name$PubSubType() {
	if(m_keyBuffer!=nullptr)
		delete(m_keyBuffer);
}

bool $struct.name$PubSubType::serialize(void *data, SerializedPayload_t *payload) {
	$struct.name$ *p_type = ($struct.name$*) data;
	eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
	eprosima::fastcdr::Cdr ser(fastbuffer,eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS); 	// Object that serializes the data.
	payload->encapsulation = CDR_LE;  	//Select the correct endianess
	p_type->serialize(ser); 	// Serialize the object:
    payload->length = (uint16_t)ser.getSerializedDataLength(); 	//Get the serialized length
	return true;
}

bool $struct.name$PubSubType::deserialize(SerializedPayload_t* payload, void* data) {
	$struct.name$* p_type = ($struct.name$*) data; 	//Convert DATA to pointer of your type
	eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); 	// Object that manages the raw buffer.
	eprosima::fastcdr::Cdr::Endianness endian = payload->encapsulation == CDR_LE ? eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS : eprosima::fastcdr::Cdr::BIG_ENDIANNESS; 	//select the correct endianess
	eprosima::fastcdr::Cdr deser(fastbuffer,endian); 	// Object that deserializes the data.
	p_type->deserialize(deser);	//Deserialize the object:
	return true;
}

void* $struct.name$PubSubType::createData() {
	return (void*)new $struct.name$();
}

void $struct.name$PubSubType::deleteData(void* data) {
	delete(($struct.name$*)data);
}

bool $struct.name$PubSubType::getKey(void *data, InstanceHandle_t* handle) {
	if(!m_isGetKeyDefined)
		return false;
	$struct.name$* p_type = ($struct.name$*) data;
	eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,$ctx.m_lastStructure$::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
	eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
	p_type->serializeKey(ser);
	if($struct.name$::getKeyMaxCdrSerializedSize()>16)	{
		m_md5.init();
		m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
		m_md5.finalize();
		for(uint8_t i = 0;i<16;++i)    	{
        	handle->value[i] = m_md5.digest[i];
    	}
    }
    else    {
    	for(uint8_t i = 0;i<16;++i)    	{
        	handle->value[i] = m_keyBuffer[i];
    	}
    }
	return true;
}

>>

union_type(ctx, union) ::= <<>>

enum_type(ctx, enum) ::= <<>>
