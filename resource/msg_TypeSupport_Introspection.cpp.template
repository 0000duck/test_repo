@###############################################
@#
@# ROS message type support code generation for C++
@#
@# EmPy template for generating <msg>_TypeSupport_Introspection.cpp files
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - spec (rosidl_parser.MessageSpecification)
@#    Parsed specification of the .msg file
@###############################################

#ifndef __@(spec.base_type.pkg_name)__@(spec.base_type.type)_TypeSupport__h__
#define __@(spec.base_type.pkg_name)__@(spec.base_type.type)_TypeSupport__h__

#include "@(spec.base_type.pkg_name)/@(spec.base_type.type)_Struct.h"
#include "rosidl_generator_cpp/MessageTypeSupport.h"
#include "rosidl_typesupport_introspection_cpp/FieldTypes.h"
#include "rosidl_typesupport_introspection_cpp/MessageIntrospection.h"

namespace @(spec.base_type.pkg_name)
{

namespace rosidl_typesupport_introspection_cpp
{

static const ::rosidl_typesupport_introspection_cpp::MessageMember @(spec.base_type.type)_message_member_array[@(len(spec.fields))] = {
@{
for index, field in enumerate(spec.fields):
    print('    {')

    # const char * name_
    print('        "%s",' % field.name)
    if field.type.is_primitive_type():
        # uint8_t type_id_
        print('        ::rosidl_typesupport_introspection_cpp::ROS_TYPE_%s,' % field.type.type.upper())
        # size_t string_upper_bound
        print('        %u,' % (field.type.string_upper_bound if field.type.string_upper_bound is not None else 0))
        # const rosidl_generator_cpp::MessageTypeSupportHandle * members_
        print('        nullptr,')
    else:
        # uint8_t type_id_
        print('        ::rosidl_typesupport_introspection_cpp::ROS_TYPE_MESSAGE,')
        # size_t string_upper_bound
        print('        0,')
        # const rosidl_message_type_support_t * members_
        print('        ::rosidl_typesupport_introspection_cpp::get_type_support_handle<%s::%s>(),' % (field.type.pkg_name, field.type.type))
    # bool is_array_
    print('        %s,' % ('true' if field.type.is_array else 'false'))
    # size_t array_size_
    print('        %u,' % (field.type.array_size if field.type.array_size and not field.type.is_upper_bound else 0))
    # bool is_upper_bound_
    print('        %s,' % ('true' if field.type.is_upper_bound else 'false'))
    # unsigned long offset_
    print('        __builtin_offsetof(%s::%s, %s)' % (spec.base_type.pkg_name, spec.base_type.type, field.name))

    if index < len(spec.fields) - 1:
        print('    },')
    else:
        print('    }')
}@
};

static const ::rosidl_typesupport_introspection_cpp::MessageMembers @(spec.base_type.type)_message_members = {
    "@(spec.base_type.pkg_name)",
    "@(spec.base_type.type)",
    @(len(spec.fields)),
    @(spec.base_type.type)_message_member_array
};

static const rosidl_message_type_support_t @(spec.base_type.type)_message_type_support_handle = {
    ::rosidl_typesupport_introspection_cpp::typesupport_introspection_identifier,
    &@(spec.base_type.type)_message_members
};

}  // namespace rosidl_typesupport_introspection_cpp

}  // namespace @(spec.base_type.pkg_name)


namespace rosidl_typesupport_introspection_cpp
{

template<>
const rosidl_message_type_support_t * get_type_support_handle<@(spec.base_type.pkg_name)::@(spec.base_type.type)>()
{
    return &::@(spec.base_type.pkg_name)::rosidl_typesupport_introspection_cpp::@(spec.base_type.type)_message_type_support_handle;
}

}  // namespace rosidl_generator_cpp

#endif  // __@(spec.base_type.pkg_name)__@(spec.base_type.type)_TypeSupport__h__
