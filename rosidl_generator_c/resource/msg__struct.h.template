// generated from rosidl_generator_c/resource/msg__struct.h.template
// generated code does not contain a copyright notice

@#######################################################################
@# EmPy template for generating <msg>__struct.h files
@#
@# Context:
@#  - spec (rosidl_parser.MessageSpecification)
@#    Parsed specification of the .msg file
@#  - subfolder (string)
@#    The subfolder / subnamespace of the message
@#    Either 'msg' or 'srv'
@#  - get_header_filename_from_msg_name (function)
@#######################################################################
@
@{
header_guard_parts = [
    spec.base_type.pkg_name, subfolder,
    get_header_filename_from_msg_name(spec.base_type.type) + '__struct_h']
header_guard_variable = '__'.join([x.upper() for x in header_guard_parts]) + '_'
}@
#ifndef @(header_guard_variable)
#define @(header_guard_variable)

@{
from rosidl_generator_c import msg_type_to_c
from rosidl_generator_c import MSG_TYPE_TO_C

c_namespace = '%s__%s__' % (spec.base_type.pkg_name, subfolder)
c_struct = '%s' % spec.base_type.type
c_full_name = '%s%s' % (c_namespace, c_struct)
}@
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include "rosidl_generator_c/arrays.h"

// include message dependencies
@{
for field in spec.fields:
    if not field.type.is_primitive_type():
        print(
            '#include "%s/msg/%s.h"' %
            (field.type.pkg_name, get_header_filename_from_msg_name(field.type.type)))
}@

// types for static array fields
@{
for field in spec.fields:
    if field.type.is_array and field.type.array_size is not None:
        if field.type.is_primitive_type():
            # find the C primitive type
            array_type = MSG_TYPE_TO_C[field.type.type]
        else:
            # use the name of the complex type
            array_type = '%s__%s__%s' % (field.type.pkg_name, 'msg', field.type.type)
        print('ROSIDL_GENERATE_STATIC_ARRAY(%s, %s, %s, %s);' %
             (c_full_name, field.name, array_type, field.type.array_size))
}@

// message struct
typedef struct @(c_full_name)
{
@[for field in spec.fields]@
  @(msg_type_to_c(field.type, field.name, c_full_name));
@[end for]@
} @(c_full_name);

// constants
@[for constant in spec.constants]@
@[if (constant.primitive_type in ['byte', 'int8', 'int16', 'int32', 'int64', 'char'])]@
enum
{
  @(c_full_name + "__" + constant.name) = @(int(constant.value))
};
@[elif (constant.primitive_type in ['uint8', 'uint16', 'uint32', 'uint64'])]@
enum
{
  @(c_full_name + "__" + constant.name) = @(int(constant.value))u
};
@[else]@
static const @(MSG_TYPE_TO_C[constant.primitive_type]) @(c_full_name + "__" + constant.name) = @(constant.value);
@[end if]@
@[end for]@

// symbols for arrays of the message type
ROSIDL_GENERATE_ARRAY(@(c_full_name));

#endif  // @(header_guard_variable)
